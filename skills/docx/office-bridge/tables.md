---
name: office-bridge-tables
description: "Table manipulation via Office Bridge Word add-in. Use when working with Word tables through Office.js - inserting, editing, formatting, and managing table data in live Word documents."
---

# Office Bridge: Table Manipulation

This skill documents table manipulation capabilities available through the Office Bridge Word add-in, which uses Office.js APIs to interact with tables in live Word documents.

## Current Table Ref System

Our DocTree accessibility layer uses a hierarchical ref system for tables:

```
tbl:0              - First table in document
tbl:0/row:1        - Second row (0-indexed) in first table
tbl:0/row:1/cell:2 - Third cell in second row of first table
tbl:0/row:1/cell:2/p:0 - First paragraph in that cell
```

These refs are generated by `builder.ts` and allow precise targeting of table elements for editing operations.

## Office.js Table APIs

### Word.Table Class

The primary class for table manipulation. Key properties and methods:

**Structure Properties (readonly)**
- `rowCount` - Number of rows
- `columns` - TableColumnCollection
- `rows` - TableRowCollection
- `isUniform` - Whether all rows have same cell count
- `nestingLevel` - 1 for top-level tables, higher for nested

**Content Property**
- `values` - Get/set 2D array of cell text values

**Styling Properties**
- `styleBuiltIn` - Apply built-in table style (portable across locales)
- `style` - Apply custom/localized style name
- `styleBandedRows` / `styleBandedColumns` - Banding toggles
- `styleFirstColumn` / `styleLastColumn` / `styleTotalRow` - Special formatting

**Layout Properties**
- `alignment` - Table alignment (left, centered, right)
- `horizontalAlignment` / `verticalAlignment` - Cell content alignment
- `width` - Table width in points

### Key Methods

```typescript
// Row operations
table.addRows("Start" | "End", rowCount, values?: string[][])
table.deleteRows(rowIndex, rowCount?)

// Column operations
table.addColumns("Start" | "End", columnCount, values?: string[][])
table.deleteColumns(columnIndex, columnCount?)
table.distributeColumns()

// Cell access
table.getCell(rowIndex, cellIndex): TableCell
table.getCellOrNullObject(rowIndex, cellIndex): TableCell

// Cell merging
table.mergeCells(topRow, firstCell, bottomRow, lastCell): TableCell

// Formatting
table.getBorder(borderLocation): TableBorder
table.getCellPadding(location): number
table.setCellPadding(location, padding)
table.autoFitBehavior("FixedSize" | "Content" | "Window")

// Content
table.clear()
table.delete()
table.search(text, options?): RangeCollection
```

### Word.TableRow Class

Properties:
- `cellCount` - Number of cells
- `cells` - TableCellCollection
- `isHeader` - Whether row is a header row
- `rowIndex` - Index in parent table
- `values` - Get/set cell text as 2D array

Methods:
- `insertRows(insertLocation, rowCount, values?)` - Insert using this row as template
- `delete()` - Delete the row
- `merge()` - Merge all cells in row
- `getBorder()` / `setCellPadding()` - Formatting

### Word.TableCell Class

Properties:
- `cellIndex` - Index in row
- `rowIndex` - Row index in table
- `body` - Body object for cell content
- `value` - Get/set cell text directly
- `columnWidth` - Width in points
- `horizontalAlignment` / `verticalAlignment`

Methods:
- `insertRows()` / `insertColumns()` - Insert adjacent rows/columns
- `deleteRow()` / `deleteColumn()` - Delete containing row/column
- `merge(mergeTo)` - Merge with another cell
- `split(rowCount, columnCount)` - Split into multiple cells
- `autoSum()` - Insert SUM formula
- `formula(options?)` - Insert custom formula

## Current Implementation in builder.ts

Our tree builder processes tables with batched loading for performance:

```typescript
// Phase 1: Load rows for all tables
for (const table of tables.items) {
  table.rows.load('items/isHeader,items/cellCount');
}
await context.sync();

// Phase 2: Load cells for all rows
for (const table of tables.items) {
  for (const row of table.rows.items) {
    row.cells.load('items');
  }
}
await context.sync();

// Phase 3: Load paragraphs for all cells
for (const table of tables.items) {
  for (const row of table.rows.items) {
    for (const cell of row.cells.items) {
      cell.body.paragraphs.load('items/text,items/style');
    }
  }
}
await context.sync();
```

This approach uses only 3 `context.sync()` calls instead of O(tables x rows x cells), significantly improving performance.

### Generated Tree Structure

```yaml
- ref: tbl:0
  role: table
  dimensions: { rows: 5, cols: 3 }
  children:
    - ref: tbl:0/row:0
      role: row
      isHeader: true
      children:
        - ref: tbl:0/row:0/cell:0
          role: cell
          text: "Header 1"
        - ref: tbl:0/row:0/cell:1
          role: cell
          text: "Header 2"
```

## Inserting Tables

### From Body (Start/End)

```typescript
await Word.run(async (context) => {
  const data = [
    ["Name", "Price", "Quantity"],
    ["Widget", "$10.00", "5"],
    ["Gadget", "$25.00", "2"]
  ];

  const table = context.document.body.insertTable(3, 3, "End", data);
  table.styleBuiltIn = Word.BuiltInStyleName.gridTable5Dark_Accent2;

  await context.sync();
});
```

### After/Before Element

```typescript
// Insert table after a specific paragraph
const para = context.document.body.paragraphs.getFirst();
const table = para.insertTable(2, 3, "After", [
  ["A", "B", "C"],
  ["D", "E", "F"]
]);
```

## Modifying Tables

### Adding Rows

```typescript
const table = context.document.body.tables.getFirst();
table.load("rows");
await context.sync();

// Add row at end with data
table.addRows("End", 1, [["New", "Row", "Data"]]);

// Add multiple rows
table.addRows("End", 3, [
  ["Row 1", "Data", "Here"],
  ["Row 2", "More", "Data"],
  ["Row 3", "Even", "More"]
]);

await context.sync();
```

### Adding Columns

```typescript
const table = context.document.body.tables.getFirst();

// Add column at end
table.addColumns("End", 1, [["Header"], ["Data1"], ["Data2"]]);

// Add column at start
table.addColumns("Start", 1, [["#"], ["1"], ["2"]]);

await context.sync();
```

### Deleting Rows/Columns

```typescript
const table = context.document.body.tables.getFirst();

// Delete row at index 2
table.deleteRows(2, 1);

// Delete rows 3-5 (3 rows starting at index 3)
table.deleteRows(3, 3);

// Delete column at index 1
table.deleteColumns(1, 1);

await context.sync();
```

### Cell Content

```typescript
const table = context.document.body.tables.getFirst();

// Direct cell access
const cell = table.getCell(1, 2);
cell.body.paragraphs.getFirst().insertText("New content", "Replace");

// Bulk update via values
table.values = [
  ["Updated", "Row", "1"],
  ["Updated", "Row", "2"]
];

await context.sync();
```

### Merging Cells

```typescript
const table = context.document.body.tables.getFirst();

// Merge cells from (0,0) to (0,2) - top row, first 3 cells
const mergedCell = table.mergeCells(0, 0, 0, 2);
mergedCell.body.paragraphs.getFirst().insertText("Merged Header", "Replace");

await context.sync();
```

### Splitting Cells

```typescript
const table = context.document.body.tables.getFirst();
const cell = table.getCell(1, 0);

// Split into 2 rows and 2 columns
cell.split(2, 2);

await context.sync();
```

## Formatting Tables

### Table Styles

```typescript
const table = context.document.body.tables.getFirst();

// Apply built-in style
table.styleBuiltIn = Word.BuiltInStyleName.gridTable5Dark_Accent2;

// Configure style options
table.styleBandedRows = true;
table.styleBandedColumns = false;
table.styleFirstColumn = true;
table.styleTotalRow = true;

await context.sync();
```

### Cell Alignment

```typescript
const table = context.document.body.tables.getFirst();

// Table-wide alignment
table.horizontalAlignment = Word.Alignment.centered;
table.verticalAlignment = Word.VerticalAlignment.center;

// Per-row alignment
const row = table.rows.getFirst();
row.horizontalAlignment = Word.Alignment.right;

await context.sync();
```

### Borders

```typescript
const table = context.document.body.tables.getFirst();

const topBorder = table.getBorder("Top");
topBorder.load("type,color,width");
await context.sync();

// Modify border
topBorder.type = Word.BorderType.single;
topBorder.color = "#000000";
topBorder.width = 1.5;

await context.sync();
```

### Cell Padding

```typescript
const table = context.document.body.tables.getFirst();

// Set padding (in points)
table.setCellPadding("Top", 10);
table.setCellPadding("Bottom", 10);
table.setCellPadding("Left", 5);
table.setCellPadding("Right", 5);

await context.sync();
```

### Auto-fit Behavior

```typescript
const table = context.document.body.tables.getFirst();

// Fit to content
table.autoFitBehavior("Content");

// Fixed width
table.autoFitBehavior("FixedSize");

// Fit to window
table.autoFitBehavior("Window");

// Distribute columns evenly
table.distributeColumns();

await context.sync();
```

## Searching in Tables

```typescript
const table = context.document.body.tables.getFirst();

const results = table.search("keyword", { matchCase: false });
results.load("items/text");
await context.sync();

for (const range of results.items) {
  console.log(`Found: ${range.text}`);
  range.font.highlightColor = "Yellow";
}
await context.sync();
```

## Formulas in Cells

```typescript
const table = context.document.body.tables.getFirst();
const cell = table.getCell(5, 2); // Row 5, Col 2

// Auto-sum cells above
cell.autoSum();

// Custom formula
cell.formula({ formula: "=SUM(ABOVE)" });

await context.sync();
```

## Best Practices

### 1. Batch Cell Access

Instead of loading cells one at a time:

```typescript
// BAD - many sync calls
for (let i = 0; i < rowCount; i++) {
  const cell = table.getCell(i, 0);
  cell.load("value");
  await context.sync();
}

// GOOD - single sync call
table.rows.load("items/cells/items/value");
await context.sync();
for (const row of table.rows.items) {
  for (const cell of row.cells.items) {
    console.log(cell.value);
  }
}
```

### 2. Use values Property for Bulk Updates

```typescript
// GOOD - single operation
table.values = [
  ["A", "B", "C"],
  ["D", "E", "F"]
];

// AVOID - multiple operations
table.getCell(0, 0).value = "A";
table.getCell(0, 1).value = "B";
// ... etc
```

### 3. Check Table Uniformity Before Column Operations

```typescript
table.load("isUniform");
await context.sync();

if (!table.isUniform) {
  console.warn("Table has varying column counts - column operations may fail");
}
```

### 4. Handle Merged Cells

Merged cells can cause unexpected behavior. Always check cell span:

```typescript
const cell = table.getCell(row, col);
cell.load("columnWidth,width");
await context.sync();
```

## Limitations

1. **Tracked Changes**: Office.js has limited support for tracked changes in tables. Use the Python library for tracked table edits.

2. **Complex Merging**: Merging non-rectangular cell ranges is not supported.

3. **Nested Tables**: Supported but require careful handling of refs (`tbl:0/row:1/cell:2/tbl:0`).

4. **Performance**: Large tables (100+ rows) may require chunked processing to avoid timeouts.

5. **Undo Stack**: Operations executed via Office.js are not always undoable in Word.

6. **API Requirements**:
   - Most features require WordApi 1.3+
   - Some features (merge, split, formulas) require WordApiDesktop 1.4

## See Also

- [office-bridge.md](../office-bridge.md) - Main Office Bridge documentation
- [Python tables.py](/src/python_docx_redline/operations/tables.py) - Python table operations with tracked changes
- [Word.Table class](https://learn.microsoft.com/en-us/javascript/api/word/word.table?view=word-js-preview) - Microsoft documentation
- [Word.TableRow class](https://learn.microsoft.com/en-us/javascript/api/word/word.tablerow?view=word-js-preview)
- [Word.TableCell class](https://learn.microsoft.com/en-us/javascript/api/word/word.tablecell?view=word-js-preview)

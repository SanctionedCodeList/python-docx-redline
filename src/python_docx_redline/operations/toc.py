"""
TOCOperations class for handling Table of Contents manipulation.

This module provides a dedicated class for TOC operations, including:
- Inserting a TOC field that Word will populate on open
- Managing settings.xml for field update behavior
- Ensuring required styles exist

The generated TOC uses Word's field codes, which means:
1. The actual TOC entries are populated by Word when opening the document
2. Page numbers are calculated by Word's layout engine
3. The TOC is marked dirty so Word updates it on open
"""

from __future__ import annotations

import logging
from typing import TYPE_CHECKING

from lxml import etree

from ..constants import WORD_NAMESPACE, XML_NAMESPACE, w
from ..models.style import ParagraphFormatting, RunFormatting, Style, StyleType

if TYPE_CHECKING:
    from ..document import Document

logger = logging.getLogger(__name__)


class TOCOperations:
    """Operations for Table of Contents manipulation.

    This class encapsulates all TOC functionality, including:
    - Inserting TOC fields at specific positions in the document
    - Configuring TOC switches (levels, hyperlinks, etc.)
    - Ensuring required styles exist
    - Managing settings.xml for automatic field updates

    The TOC generated by this class relies on Word's field calculation.
    When the document is opened in Word, it will populate the TOC with
    actual entries and page numbers based on the document's heading structure.

    Example:
        >>> doc = Document("report.docx")
        >>> doc.insert_toc(levels=(1, 3), title="Contents")
        >>> doc.save("report_with_toc.docx")
    """

    def __init__(self, document: Document) -> None:
        """Initialize TOCOperations with a Document reference.

        Args:
            document: The Document instance to operate on
        """
        self._document = document

    def insert_toc(
        self,
        position: int | str = 0,
        levels: tuple[int, int] = (1, 3),
        title: str | None = "Table of Contents",
        hyperlinks: bool = True,
        show_page_numbers: bool = True,
        use_outline_levels: bool = True,
        update_on_open: bool = True,
    ) -> None:
        """Insert a TOC field that Word will populate on open.

        This method inserts a Table of Contents field into the document at the
        specified position. The TOC is wrapped in a Structured Document Tag (SDT)
        which Word recognizes as a TOC content control.

        The TOC field is marked as dirty, meaning Word will update it when the
        document is opened. If update_on_open is True, the w:updateFields setting
        is also enabled in settings.xml.

        Args:
            position: Where to insert the TOC. Can be:
                     - int: Paragraph index (0 = beginning of document)
                     - "start": Beginning of document body
                     - "end": End of document body (before sectPr)
            levels: Tuple of (min_level, max_level) for heading levels to include.
                   Default (1, 3) includes Heading 1, 2, and 3.
            title: Optional title text to display above the TOC.
                  Set to None for no title. Default is "Table of Contents".
            hyperlinks: If True (default), TOC entries link to their headings.
                       Corresponds to the \\h switch.
            show_page_numbers: If True (default), show page numbers.
                              If False, adds \\n switch to suppress page numbers.
            use_outline_levels: If True (default), include paragraphs with outline
                               levels. Corresponds to the \\u switch.
            update_on_open: If True (default), sets w:updateFields in settings.xml
                           so Word updates all fields when opening the document.

        Example:
            >>> doc = Document("report.docx")
            >>> # Simple TOC with defaults
            >>> doc.insert_toc()
            >>>
            >>> # TOC without title, including more heading levels
            >>> doc.insert_toc(title=None, levels=(1, 5))
            >>>
            >>> # TOC at end of document without page numbers
            >>> doc.insert_toc(position="end", show_page_numbers=False)
        """
        # Ensure TOCHeading style exists
        self._ensure_toc_heading_style()

        # Build the field instruction string
        field_instruction = self._build_field_instruction(
            levels=levels,
            hyperlinks=hyperlinks,
            show_page_numbers=show_page_numbers,
            use_outline_levels=use_outline_levels,
        )

        # Build XML elements
        elements_to_insert = []

        # Add title paragraph if requested
        if title is not None:
            title_para = self._create_title_paragraph(title)
            elements_to_insert.append(title_para)

        # Create the SDT with TOC field
        sdt_element = self._create_toc_sdt(field_instruction)
        elements_to_insert.append(sdt_element)

        # Find insertion point and insert elements
        body = self._document.xml_root.find(f".//{{{WORD_NAMESPACE}}}body")
        if body is None:
            raise ValueError("Document has no body element")

        insert_index = self._resolve_position(body, position)

        # Insert elements in order at the resolved position
        for i, elem in enumerate(elements_to_insert):
            body.insert(insert_index + i, elem)

        # Update settings.xml if requested
        if update_on_open:
            self._set_update_fields_on_open()

        # Save changes to document.xml
        self._save_document_xml()

        logger.info(f"Inserted TOC at position {position} with levels {levels}")

    def _build_field_instruction(
        self,
        levels: tuple[int, int],
        hyperlinks: bool,
        show_page_numbers: bool,
        use_outline_levels: bool,
    ) -> str:
        """Build the TOC field instruction string.

        Args:
            levels: Tuple of (min, max) heading levels
            hyperlinks: Whether to include hyperlinks
            show_page_numbers: Whether to show page numbers
            use_outline_levels: Whether to include outline levels

        Returns:
            Field instruction string like ' TOC \\o "1-3" \\h \\z \\u '
        """
        parts = [" TOC"]

        # \o switch for heading levels
        min_level, max_level = levels
        parts.append(f'\\o "{min_level}-{max_level}"')

        # \h switch for hyperlinks
        if hyperlinks:
            parts.append("\\h")

        # \z switch (hide in web view) - always include
        parts.append("\\z")

        # \u switch for outline levels
        if use_outline_levels:
            parts.append("\\u")

        # \n switch to suppress page numbers
        if not show_page_numbers:
            parts.append("\\n")

        # Add trailing space
        return " ".join(parts) + " "

    def _create_title_paragraph(self, title: str) -> etree._Element:
        """Create the TOC title paragraph.

        Args:
            title: The title text

        Returns:
            A w:p element with the title
        """
        nsmap = {None: WORD_NAMESPACE}

        # Create paragraph
        para = etree.Element(w("p"), nsmap=nsmap)

        # Add paragraph properties with TOCHeading style
        ppr = etree.SubElement(para, w("pPr"))
        pstyle = etree.SubElement(ppr, w("pStyle"))
        pstyle.set(w("val"), "TOCHeading")

        # Add run with text
        run = etree.SubElement(para, w("r"))
        text_elem = etree.SubElement(run, w("t"))
        text_elem.text = title

        return para

    def _create_toc_sdt(self, field_instruction: str) -> etree._Element:
        """Create the SDT (Structured Document Tag) containing the TOC field.

        Args:
            field_instruction: The TOC field instruction string

        Returns:
            A w:sdt element containing the complete TOC field structure
        """
        nsmap = {None: WORD_NAMESPACE}

        # Create SDT container
        sdt = etree.Element(w("sdt"), nsmap=nsmap)

        # SDT properties - must use docPartObj wrapper per OOXML schema
        sdt_pr = etree.SubElement(sdt, w("sdtPr"))
        # Per schema, docPartObj contains docPartGallery and docPartUnique
        doc_part_obj = etree.SubElement(sdt_pr, w("docPartObj"))
        doc_part_gallery = etree.SubElement(doc_part_obj, w("docPartGallery"))
        doc_part_gallery.set(w("val"), "Table of Contents")
        etree.SubElement(doc_part_obj, w("docPartUnique"))

        # SDT content
        sdt_content = etree.SubElement(sdt, w("sdtContent"))

        # Create the paragraph containing the field
        para = etree.SubElement(sdt_content, w("p"))

        # Field begin with dirty flag
        run_begin = etree.SubElement(para, w("r"))
        fld_char_begin = etree.SubElement(run_begin, w("fldChar"))
        fld_char_begin.set(w("fldCharType"), "begin")
        fld_char_begin.set(w("dirty"), "true")

        # Field instruction
        run_instr = etree.SubElement(para, w("r"))
        instr_text = etree.SubElement(run_instr, w("instrText"))
        instr_text.set(f"{{{XML_NAMESPACE}}}space", "preserve")
        instr_text.text = field_instruction

        # Field separate
        run_sep = etree.SubElement(para, w("r"))
        fld_char_sep = etree.SubElement(run_sep, w("fldChar"))
        fld_char_sep.set(w("fldCharType"), "separate")

        # Placeholder text
        run_placeholder = etree.SubElement(para, w("r"))
        text_placeholder = etree.SubElement(run_placeholder, w("t"))
        text_placeholder.text = "Update this table"

        # Field end
        run_end = etree.SubElement(para, w("r"))
        fld_char_end = etree.SubElement(run_end, w("fldChar"))
        fld_char_end.set(w("fldCharType"), "end")

        return sdt

    def _resolve_position(self, body: etree._Element, position: int | str) -> int:
        """Resolve position specification to an index in the body.

        Args:
            body: The w:body element
            position: Position specification (int, "start", or "end")

        Returns:
            Integer index for insertion

        Raises:
            ValueError: If position specification is invalid
        """
        if isinstance(position, int):
            return max(0, min(position, len(body)))

        if position == "start":
            return 0

        if position == "end":
            # Insert before sectPr if it exists
            children = list(body)
            if children and children[-1].tag == w("sectPr"):
                return len(children) - 1
            return len(children)

        raise ValueError(f"Invalid position: {position}. Use int, 'start', or 'end'")

    def _ensure_toc_heading_style(self) -> None:
        """Ensure the TOCHeading style exists in the document.

        Creates the style if it doesn't exist, using Word's standard
        TOCHeading style definition (bold, larger font).
        """
        styles = self._document.styles
        if "TOCHeading" in styles:
            return

        # Create TOCHeading style
        # Note: We avoid keep_next here due to a StyleManager bug with element ordering
        style = Style(
            style_id="TOCHeading",
            name="TOC Heading",
            style_type=StyleType.PARAGRAPH,
            based_on="Heading1",
            next_style="Normal",
            paragraph_formatting=ParagraphFormatting(
                spacing_before=12.0,
                spacing_after=6.0,
            ),
            run_formatting=RunFormatting(
                bold=True,
                font_size=14.0,
            ),
            ui_priority=39,
            unhide_when_used=True,
        )

        styles.add(style)
        self._ensure_styles_relationship()
        self._ensure_styles_content_type()
        styles.save()

    def _ensure_styles_relationship(self) -> None:
        """Ensure styles.xml relationship exists in document.xml.rels."""
        from ..relationships import RelationshipManager, RelationshipTypes

        package = self._document._package
        if not package:
            return

        rel_mgr = RelationshipManager(package, "word/document.xml")
        rel_mgr.add_relationship(RelationshipTypes.STYLES, "styles.xml")
        rel_mgr.save()

    def _ensure_styles_content_type(self) -> None:
        """Ensure styles.xml content type exists in [Content_Types].xml."""
        from ..content_types import ContentTypeManager, ContentTypes

        package = self._document._package
        if not package:
            return

        ct_mgr = ContentTypeManager(package)
        ct_mgr.add_override("/word/styles.xml", ContentTypes.STYLES)
        ct_mgr.save()

    def _set_update_fields_on_open(self) -> None:
        """Set w:updateFields in settings.xml so Word updates fields on open.

        This ensures the TOC is populated when the document is opened.
        If settings.xml doesn't exist, it creates a minimal one.
        """
        package = self._document._package
        if package is None:
            logger.warning("Cannot update settings.xml: no package")
            return

        temp_dir = package.temp_dir
        settings_path = temp_dir / "word" / "settings.xml"

        if settings_path.exists():
            # Parse existing settings.xml
            parser = etree.XMLParser(remove_blank_text=False)
            tree = etree.parse(str(settings_path), parser)
            root = tree.getroot()
        else:
            # Create minimal settings.xml
            nsmap = {"w": WORD_NAMESPACE}
            root = etree.Element(f"{{{WORD_NAMESPACE}}}settings", nsmap=nsmap)
            tree = etree.ElementTree(root)

        # Check if updateFields already exists
        update_fields = root.find(w("updateFields"))
        if update_fields is not None:
            # Already set, ensure value is true
            update_fields.set(w("val"), "true")
        else:
            # Add updateFields element
            update_fields = etree.SubElement(root, w("updateFields"))
            update_fields.set(w("val"), "true")

        # Ensure directory exists
        settings_path.parent.mkdir(parents=True, exist_ok=True)

        # Write settings.xml
        tree.write(
            str(settings_path),
            encoding="utf-8",
            xml_declaration=True,
            standalone=True,
        )

        # Ensure settings.xml is registered in relationships and content types
        self._ensure_settings_relationship()
        self._ensure_settings_content_type()

        logger.debug("Set updateFields=true in settings.xml")

    def _ensure_settings_relationship(self) -> None:
        """Ensure settings.xml relationship exists in document.xml.rels."""
        from ..relationships import RelationshipManager, RelationshipTypes

        package = self._document._package
        if not package:
            return

        rel_mgr = RelationshipManager(package, "word/document.xml")
        rel_mgr.add_relationship(RelationshipTypes.SETTINGS, "settings.xml")
        rel_mgr.save()

    def _ensure_settings_content_type(self) -> None:
        """Ensure settings.xml content type exists in [Content_Types].xml."""
        from ..content_types import ContentTypeManager, ContentTypes

        package = self._document._package
        if not package:
            return

        ct_mgr = ContentTypeManager(package)
        ct_mgr.add_override("/word/settings.xml", ContentTypes.SETTINGS)
        ct_mgr.save()

    def _save_document_xml(self) -> None:
        """Save changes to document.xml."""
        package = self._document._package
        if package is None:
            return

        doc_path = package.temp_dir / "word" / "document.xml"
        self._document.xml_tree.write(
            str(doc_path),
            encoding="utf-8",
            xml_declaration=True,
            standalone=True,
        )
